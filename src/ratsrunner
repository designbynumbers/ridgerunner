#!/usr/bin/perl

#
# ratsrunner runs the Ridgerunner Automated Test Suite (RATS), which is a collection of 
# simple test problems intended to benchmark the ridgerunner system and make sure that 
# changes to the algorithm don't cause unintended side effects.
#

#
# the script is intended to be run only from the /src directory (it is not installed by
# default, though it is run as part of make check). The script updates the files ratsDB.pl
# and (if you have gnuplot) ratsgraph.pdf when you run it.
#

#
# the script stomps the local subdirectory ./ratsworking (we need to preserve the .rr 
# directories generated by the runs in case they don't complete as expected).
#

# ratsrunner will also take  "--rrargs=" stuff " " which gives any and
# all additional ridgerunner arguments which are common to all the runs.

#
# the program reports a relative performance score in "rats", based on
# the performance of the initial runs on a test machine at UGA, which
# was decreed to have 100 rats worth of performance
#

use strict;
use File::Temp;
use File::Copy;
use File::Slurp qw( slurp ) ;
use File::Path;
use Data::Dumper;
use Sys::Hostname;
use warnings;
use Getopt::Long;

my $svnversion;
my $ratsversion;
my $hostname;
my $rawtime;
my $nrats;
my $timestamp;
my $wd;

#
# We start by collecting data about the machine and the version of rats and ridgerunner.
#

$svnversion = `svnversion -n`;
$hostname = hostname( );
$ratsversion = $Revision$ ;
$wd = pwd( );

#
# Now we print some of this data for the user.
#

print "RATSrunner $ratsversion performing tests on ridgerunner $svnversion on $hostname.\n";
print "This sequence of automated tests should take about 60 seconds to run. Testing will";
print "be aborted after 5 minutes.";

print "The files for the runs will appear in $wd/ratsworking.";

#
# Now we parse the input arguments.
# 

my $filename;
my $ropelen_before;
my $ropelen_after;
my $residual_before;
my $residual_after;

format PROGRESS_COMPLETE_TOP =

     RATS tests

     Filename               Ropelength                              Residual
                            Before              After               Before    After
     ---------------------  ------------------  ------------------  --------  --------
.

format PROGRESS_COMPLETE = 
     @<<<<<<<<<<<<<<<<<<<<  @####.############  @####.############  @#.#####  @#.#####
     $filename,             $ropelen_before,    $ropelen_after,     $residual_before, $residual_after 
.

format PROGRESS_INCOMPLETE_TOP = 

     Incomplete Files 

     Filename
     ---------------------
.

format PROGRESS_INCOMPLETE = 
     @<<<<<<<<<<<<<<<<<<<<
     $filename
.

my $rrargs = '';

GetOptions ( 'rrargs=s' => \$rrargs );

#
# We now create the ./ratsworking directory if needed.
#

  unless (-d "./ratsworking") { 

      mkpath("./ratsworking") or die("Couldn't create ./ratsworking");

  }

#
# And we're now ready to start the actual RATS runs.
#  

chdir("./ratsworking") or die("Couldn't chdir to ./ratsworking");

my @runs;

$runs[1] = `ridgerunner ../../data/sticktrefoil.vect --NoPNGOutput --StopTime=5 --StopRes=0.01 $rrargs`;
$runs[2] = `ridgerunner ../../data/
$runs[3] = `ridgerunner ../../data/9.2.6.vect --NoPNGOutput --StopTime=10 --StopRes=0.01 $rrargs`;


  print "Making script for ".scalar @runfiles." VECT files.\n";

  my $ridgerunner; 
  $ridgerunner = `which ridgerunner`;
  chomp($ridgerunner);
  
  my $wd;
  $wd = `pwd`;
  chomp($wd);
  
  
  if ($gridstuffer) {

    print "GRIDSTUFFER mode\n\n";

    # open the GridStuffer script file. 
    
    $ridgerunner = "~/../..".$ridgerunner;

    # we need to construct a relative path for ridgerunner in order to 
    # ensure that this version of rr will be uploaded to all of the grid
    # machines. 

    open (GRIDSTUFFER, '>gridstuffer.txt');

    print GRIDSTUFFER "-dirs $wd/inputs \n";
    
    foreach (@runfiles) { 

	print GRIDSTUFFER "$ridgerunner $_ $rrargs \n";

    }

    close(GRIDSTUFFER);

    print "Generated file gridstuffer.txt. Contents: \n\n";
    print `cat gridstuffer.txt`;
    print "\n\n";

    print <<EndInstructions

	The next step is for you to feed the file gridstuffer.txt to 
        GridStuffer as a metajob. You should set the output directory
	to $wd/working. 

	You can collect the results with 

	batchrunner --harvest --gridstuffer

	which will move completed files to ./outputs and generate 
        a report in progress_report.txt in this directory. You can 
        run batchrunner --harvest --gridstuffer as many times as 
        you like as long as you don't delete anything in ./working.

EndInstructions

  }

  if ($local) {

      my $hostname;

      $hostname = `hostname`;
      chomp($hostname);

      print("LOCAL mode\n");

      print "Copying input files to ./working.\n";

      foreach (@runfiles) {
	  
	  copy($_,"./working/") or die("Couldn't copy $_ to ./working.");
	  
      }

      chdir("./working");

      my @workingfiles = <*.vect>;
      
      print("Generating a shell script to do runs on $hostname.\n");

      open (LOCALSCRIPT,">start_runs.sh");

      my $timestamp;
      $timestamp = `date`;
      chomp($timestamp);

      print LOCALSCRIPT "echo Starting ".scalar @runfiles." ridgerunner runs.\n";
      print LOCALSCRIPT "echo This script autogenerated by batchrunner at $timestamp.\n";

      foreach (@workingfiles) {

	  my $outputname;

	  $outputname = $_;
	  $outputname =~ s/vect/output/;

      print LOCALSCRIPT "nohup nice -n 20  $ridgerunner $_ $rrargs 2>$outputname 1>$outputname ".' &'."\n";

      }

      close(LOCALSCRIPT);

      chmod 0755, "start_runs.sh"; # corresponds to rwxr-xr-x

      print "Running the shell script ./working/start_runs.sh.\n\n";

      my $scriptresults = '';
      $scriptresults = `./start_runs.sh`;

      print "Output: \n\n$scriptresults\n";

  } 

  #
  # Need to develop some scripts for the ACCRE qsub environment.
  #

  if ($accre) {

      print "ACCRE/qsub environment not yet implemented.\n";
      die();

  }
      
}

if ($reap) {

    if ($gridstuffer) {

     print("Copying completed files to ./outputs...\n");

     # We expect to find outputs in ./working/1/ ./working/2/ and so forth.
     
     my @gridstufferdirs = <./working/[0-9]*>;  # Ok, this is everything that starts with a number.

     print "Found gridstuffer dirs: @gridstufferdirs\n";

     foreach (@gridstufferdirs) {

      if (-d $_) {

        my @rrdirs = <$_/*.rr/>;
        my $thisdir;

        print("\tContains rr dirs: @rrdirs.\n");

        foreach $thisdir (@rrdirs) {

           my $basename;

           $thisdir =~ m/.+\/(.+)\.rr/;
           $basename = $1;

           print "Looking for $thisdir$basename.final.vect...\n";
           if (-e "$thisdir$basename.final.vect") {

              copy("$thisdir$basename.final.vect","./outputs/$basename.vect") or die("Couldn't copy $thisdir/$basename.final.vect to ./outputs/$basename.vect");
 
           }
          
         }  
 
       }

      }
     
    }

    if ($local) {  

      #
      # We expect to find output files in the ./working subdirectory 
      # The first step is to copy the files to ./outputs
      #

      my @rrdirs = <./working/*.rr>;
      my @inputfiles  = <./inputs/*.vect>;

      foreach (@rrdirs) { 

	my $basename;

	$_ =~ m/\.\/working\/(.+)\.rr/g;
	$basename = $1;

	if (-e "$_/$basename.final.vect") {

	  copy("$_/$basename.final.vect","./outputs/$basename.vect") or 
	    die("Couldn't copy $basename.final.vect to ./outputs");

	}

      }

    }

    #
    # In order to conserve coding effort, we assume that whatever our batch computing model
    # we have now moved any outputs that we have into ./outputs and that filenames match from
    # ./inputs to ./outputs. 
    #
    # We are going to recompute ropelengths and residuals as we prepare the output report. 
    # This is a little slow, but it's easier to code than trying to pry that out of the 
    # .rr directories in ./working.
    #

    my @inputfiles = <./inputs/*.vect>;
    my @outputfiles = <./outputs/*.vect>;

    #
    # The first step is to match inputfiles and outputfiles to figure out what has completed.
    #

    my @completed;
    my @incomplete;

    foreach (@inputfiles) {

      my $filename;
      m/\.\/inputs\/(.+)/;
      $filename = $1;

      if ( grep { $_ eq "./outputs/$filename" } @outputfiles ) {

	push(@completed,$filename);

      } else {

	push(@incomplete,$filename);

      }
         
    }

    print scalar @completed." of ".scalar @inputfiles." files completed.\n";
    print "Preparing progress report (saved to batchrunner_progress.txt):\n";

    open(PROGRESS_COMPLETE,">./batchrunner_progress.txt");

    foreach (@completed) {

      $filename = $_;
      $ropelen_before = &ropelength("./inputs/$filename");
      $ropelen_after = &ropelength("./outputs/$filename");
      $residual_before = &residual("./inputs/$filename");
      $residual_after = &residual("./outputs/$filename");

      write(PROGRESS_COMPLETE);

    }

    close(PROGRESS_COMPLETE);

    open(PROGRESS_INCOMPLETE,">>./batchrunner_progress.txt"); #append the new results

    foreach (@incomplete) {

      $filename = $_;
      write(PROGRESS_INCOMPLETE);

    }

    close(PROGRESS_INCOMPLETE);

    open(BRP,"<./batchrunner_progress.txt");
    while (<BRP>) { print $_; }
    close(BRP);

}

sub ropelength { 
     my $filename;
     $filename = $_[0];
     my $ropelength;

     open (ROPELENGTH,"ropelength $filename |");
     while (<ROPELENGTH>) {
       if (/:Ropelength:\s*(\S+)/) {
	 $ropelength = $1;
       }
     }
     close ROPELENGTH;

     $ropelength;
   }

sub residual {
     my $filename;
     $filename = $_[0];
     my $residual;

     open (RESIDUAL,"residual.pl $filename |");
     while (<RESIDUAL>) {
       if (/Residual:\s*(\S+)/) {
	 $residual = $1;
       }
     }
     close RESIDUAL;

     $residual;
   }

    


