#!/usr/bin/perl

#
# Batchrunner. Puts a directory of inputs through the rr machine.
#

#batchrunner takes arguments 

#"--accre"
#"--gridstuffer"
#"--local"

#which change the behavior depending on the batch computing
#environment you happen to be in. In addition, we always require that
#the user specify

#"--sow" 

#which prepares (or starts) a run

#or 

#"--harvest" (or --reap)

#which collects data from the run. 

#The batchrunner script is always intended to be run inside a
#directory of vect files. The script creates

#./inputs
#./outputs
#./working

#Batchrunner also expects "--rrargs=" stuff " " which gives any and
#all ridgerunner arguments which are common to all the runs.

#When run with --sow:

#Step 1. Move all vect files in the current directory to ./inputs (if any).

#Step 2. Create a job file (depending on environment) to run. This
#file places job output in ./working. The user may need to submit this
#manually, in which case the runs ends with instructions to the user
#to this effect. If possible (eg. on accre or on the local machine),
#we simply go ahead and spawn all the jobs from ./working.

#When run with --harvest:

#Step 1. Look in the ./working directory to find any and all completed
#runs. Exactly where to look depends on the batch method.

#Step 2. On finding .final.vect files in the appropriate places,
#rename and copy those files to the /outputs directory.

#Last, prepare a batchrunner_report.txt file which compares the list
#of files in the ./inputs directory to the list of files in the
#./outputs directory and computes stats (ropelength/residual) for the
#files in the outputs directory.

#<filename> <completed/INCOMPLETE> Verts/Resolution Ropelength Residual.

use strict;
use File::Temp;
use File::Copy;
use File::Slurp qw( slurp ) ;
use File::Path;
use warnings;
use Getopt::Long;

my $filename;
my $ropelen_before;
my $ropelen_after;
my $residual_before;
my $residual_after;

format PROGRESS_COMPLETE_TOP =

     Completed Files

     Filename               Ropelength                              Residual
                            Before              After               Before    After
     ---------------------  ------------------  ------------------  --------  --------
.

format PROGRESS_COMPLETE = 
     @<<<<<<<<<<<<<<<<<<<<  @####.############  @####.############  @#.#####  @#.#####
     $filename,             $ropelen_before,    $ropelen_after,     $residual_before, $residual_after 
.

format PROGRESS_INCOMPLETE_TOP = 

     Incomplete Files 

     Filename
     ---------------------
.

format PROGRESS_INCOMPLETE = 
     @<<<<<<<<<<<<<<<<<<<<
     $filename
.

print STDERR "batchrunner 1.0\n";

my $accre = '';
my $gridstuffer = '';
my $local = '';
my $rrargs = '';
my $sow = '';
my $reap = '';

GetOptions ( 'accre' => \$accre, 'gridstuffer' => \$gridstuffer, 'local' => \$local, 'rrargs=s' => \$rrargs, 'sow' => \$sow, 'harvest|reap' => \$reap );

if (!($sow || $reap) || !($gridstuffer || $accre || $local) || ($sow && !$rrargs)) {

print <<EndUsage 

  batchrunner is used in a directory of VECT files to run them
  in an organized way. A valid batchrunner command line must include

     --sow or --reap : whether to begin runs or check for output

     --accre or --gridstuffer or --local: specify batch computing 
        environment. --accre and --local will actually start runs,
        while --gridstuffer will only prepare a GridStuffer batch 
        file. --local runs are always run with nice -n 20.

     --rrargs="--StopRes=0.01" : arguments (other than filenames) to 
        be passed to ridgerunner. At the very least, this should include
        a valid ridgerunner stopping criterion, such as --StopRes or 
        --StopTime.

  batchrunner will move VECT files in the run directory to ./inputs.
  batchrunner will place intermediate results (depending on the batch
  computing environment) in ./working. When called with --reap, final
  results will be copied to ./outputs. --reap also generates a report
  in ./batchrunner_progress.txt which summarizes the state of the runs.
 
EndUsage

die;

}

if ($sow && $reap) { die("batchrunner: Can't sow and reap on the same run.\n"); }

if ($sow) {

  my @vectfiles = <*.vect>;

  print "Adding ".scalar @vectfiles." files to ./inputs.\n";

  unless (-d "./inputs") { 

      mkpath("./inputs") or die("Couldn't create ./inputs");

  }

  # We now move the vectfiles into ./inputs. 

  foreach (@vectfiles) { 

      move($_,"./inputs/") or die("Couldn't move $_ to ./inputs/");

  }

  my @inputfiles = <./inputs/*.vect>;
  my @donefiles = <./outputs/*.vect>;
  my @runfiles;

  #
  #  We now need to take the runfiles and subtract the donefiles.
  #

  foreach (@inputfiles) {

    my $donename;

    /.\/inputs\/(.+)/;
    $donename = "./outputs/$1";

    unless (grep /$donename/, @donefiles) { push @runfiles,$_; }

  }

  unless (-d "./working") {

      mkdir("./working") or die("Couldn't make ./working.\n");

  }

  unless (-d "./outputs") {

      mkdir("./outputs") or die("Couldn't make ./outputs.\n");

  }

  if (scalar @runfiles == 0) { 

      die("No VECT files found in working directory or ./inputs.\n");

  }

  print "Making script for ".scalar @runfiles." VECT files.\n";

  my $ridgerunner; 
  $ridgerunner = `which ridgerunner`;
  chomp($ridgerunner);
  
  my $wd;
  $wd = `pwd`;
  chomp($wd);
  
  
  if ($gridstuffer) {

    print "GRIDSTUFFER mode\n\n";

    # open the GridStuffer script file. 
    
    $ridgerunner = "~/../..".$ridgerunner;

    # we need to construct a relative path for ridgerunner in order to 
    # ensure that this version of rr will be uploaded to all of the grid
    # machines. 

    open (GRIDSTUFFER, '>gridstuffer.txt');

    print GRIDSTUFFER "-dirs $wd/inputs \n";
    
    foreach (@runfiles) { 

	print GRIDSTUFFER "$ridgerunner $_ $rrargs \n";

    }

    close(GRIDSTUFFER);

    print "Generated file gridstuffer.txt. Contents: \n\n";
    print `cat gridstuffer.txt`;
    print "\n\n";

    print <<EndInstructions

	The next step is for you to feed the file gridstuffer.txt to 
        GridStuffer as a metajob. You should set the output directory
	to $wd/working. 

	You can collect the results with 

	batchrunner --harvest --gridstuffer

	which will move completed files to ./outputs and generate 
        a report in progress_report.txt in this directory. You can 
        run batchrunner --harvest --gridstuffer as many times as 
        you like as long as you don't delete anything in ./working.

EndInstructions

  }

  if ($local) {

      my $hostname;

      $hostname = `hostname`;
      chomp($hostname);

      print("LOCAL mode\n");

      print "Copying input files to ./working.\n";

      foreach (@runfiles) {
	  
	  copy($_,"./working/") or die("Couldn't copy $_ to ./working.");
	  
      }

      chdir("./working");

      my @workingfiles = <*.vect>;
      
      print("Generating a shell script to do runs on $hostname.\n");

      open (LOCALSCRIPT,">start_runs.sh");

      my $timestamp;
      $timestamp = `date`;
      chomp($timestamp);

      print LOCALSCRIPT "echo Starting ".scalar @runfiles." ridgerunner runs.\n";
      print LOCALSCRIPT "echo This script autogenerated by batchrunner at $timestamp.\n";

      foreach (@workingfiles) {

	  my $outputname;

	  $outputname = $_;
	  $outputname =~ s/vect/output/;

      print LOCALSCRIPT "nohup nice -n 20  $ridgerunner $_ $rrargs 2>$outputname 1>$outputname ".' &'."\n";

      }

      close(LOCALSCRIPT);

      chmod 0755, "start_runs.sh"; # corresponds to rwxr-xr-x

      print "Running the shell script ./working/start_runs.sh.\n\n";

      my $scriptresults = '';
      $scriptresults = `./start_runs.sh`;

      print "Output: \n\n$scriptresults\n";

  } 

  #
  # Need to develop some scripts for the ACCRE qsub environment.
  #

  if ($accre) {

      print "ACCRE/qsub environment not yet implemented.\n";
      die();

  }
      
}

if ($reap) {

    if ($gridstuffer) {

     print("Copying completed files to ./outputs...\n");

     # We expect to find outputs in ./working/1/ ./working/2/ and so forth.
     
     my @gridstufferdirs = <./working/[0-9]*>;  # Ok, this is everything that starts with a number.

     print "Found gridstuffer dirs: @gridstufferdirs\n";

     foreach (@gridstufferdirs) {

      if (-d $_) {

        my @rrdirs = <$_/*.rr/>;
        my $thisdir;

        print("\tContains rr dirs: @rrdirs.\n");

        foreach $thisdir (@rrdirs) {

           my $basename;

           $thisdir =~ m/.+\/(.+)\.rr/;
           $basename = $1;

           print "Looking for $thisdir$basename.final.vect...\n";
           if (-e "$thisdir$basename.final.vect") {

              copy("$thisdir$basename.final.vect","./outputs/$basename.vect") or die("Couldn't copy $thisdir/$basename.final.vect to ./outputs/$basename.vect");
 
           }
          
         }  
 
       }

      }
     
    }

    if ($local) {  

      #
      # We expect to find output files in the ./working subdirectory 
      # The first step is to copy the files to ./outputs
      #

      my @rrdirs = <./working/*.rr>;
      my @inputfiles  = <./inputs/*.vect>;

      foreach (@rrdirs) { 

	my $basename;

	$_ =~ m/\.\/working\/(.+)\.rr/g;
	$basename = $1;

	if (-e "$_/$basename.final.vect") {

	  copy("$_/$basename.final.vect","./outputs/$basename.vect") or 
	    die("Couldn't copy $basename.final.vect to ./outputs");

	}

      }

    }

    #
    # In order to conserve coding effort, we assume that whatever our batch computing model
    # we have now moved any outputs that we have into ./outputs and that filenames match from
    # ./inputs to ./outputs. 
    #
    # We are going to recompute ropelengths and residuals as we prepare the output report. 
    # This is a little slow, but it's easier to code than trying to pry that out of the 
    # .rr directories in ./working.
    #

    my @inputfiles = <./inputs/*.vect>;
    my @outputfiles = <./outputs/*.vect>;

    #
    # The first step is to match inputfiles and outputfiles to figure out what has completed.
    #

    my @completed;
    my @incomplete;

    foreach (@inputfiles) {

      my $filename;
      m/\.\/inputs\/(.+)/;
      $filename = $1;

      if ( grep { $_ eq "./outputs/$filename" } @outputfiles ) {

	push(@completed,$filename);

      } else {

	push(@incomplete,$filename);

      }
         
    }

    print scalar @completed." of ".scalar @inputfiles." files completed.\n";
    print "Preparing progress report (saved to batchrunner_progress.txt):\n";

    open(PROGRESS_COMPLETE,">./batchrunner_progress.txt");

    foreach (@completed) {

      $filename = $_;
      $ropelen_before = &ropelength("./inputs/$filename");
      $ropelen_after = &ropelength("./outputs/$filename");
      $residual_before = &residual("./inputs/$filename");
      $residual_after = &residual("./outputs/$filename");

      write(PROGRESS_COMPLETE);

    }

    close(PROGRESS_COMPLETE);

    open(PROGRESS_INCOMPLETE,">>./batchrunner_progress.txt"); #append the new results

    foreach (@incomplete) {

      $filename = $_;
      write(PROGRESS_INCOMPLETE);

    }

    close(PROGRESS_INCOMPLETE);

    open(BRP,"<./batchrunner_progress.txt");
    while (<BRP>) { print $_; }
    close(BRP);

}

sub ropelength { 
     my $filename;
     $filename = $_[0];
     my $ropelength;

     open (ROPELENGTH,"ropelength $filename |");
     while (<ROPELENGTH>) {
       if (/:Ropelength:\s*(\S+)/) {
	 $ropelength = $1;
       }
     }
     close ROPELENGTH;

     $ropelength;
   }

sub residual {
     my $filename;
     $filename = $_[0];
     my $residual;

     open (RESIDUAL,"residual.pl $filename |");
     while (<RESIDUAL>) {
       if (/Residual:\s*(\S+)/) {
	 $residual = $1;
       }
     }
     close RESIDUAL;

     $residual;
   }

    


